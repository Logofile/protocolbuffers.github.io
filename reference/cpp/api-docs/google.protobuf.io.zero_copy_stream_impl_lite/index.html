<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.107.0"><meta name=robots content="index, follow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>Protocol Buffers Documentation</title><meta name=description content="zero_copy_stream_impl_lite.hzero_copy_stream_impl_lite.h#include &amp;lt;google/protobuf/io/zero_copy_stream_impl_lite.h&amp;gt;
namespace google::protobuf::io
This file contains common implementations of the interfaces defined in zero_copy_stream.h which are included in the &#34;lite&#34; protobuf library. These implementations cover I/O on raw arrays and strings, as well as adaptors which make it easy to implement streams based on traditional streams. Of course, many users will probably want to write their own implementations of these interfaces specific to the particular I/O abstractions they prefer to use, but these should cover the most common cases."><meta property="og:title" content><meta property="og:description" content="zero_copy_stream_impl_lite.hzero_copy_stream_impl_lite.h#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
namespace google::protobuf::io
This file contains common implementations of the interfaces defined in zero_copy_stream.h which are included in the &#34;lite&#34; protobuf library. These implementations cover I/O on raw arrays and strings, as well as adaptors which make it easy to implement streams based on traditional streams. Of course, many users will probably want to write their own implementations of these interfaces specific to the particular I/O abstractions they prefer to use, but these should cover the most common cases."><meta property="og:type" content="article"><meta property="og:url" content="/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl_lite/"><meta property="article:section" content="reference"><meta property="og:site_name" content="Protocol Buffers Documentation"><meta itemprop=name content><meta itemprop=description content="zero_copy_stream_impl_lite.hzero_copy_stream_impl_lite.h#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
namespace google::protobuf::io
This file contains common implementations of the interfaces defined in zero_copy_stream.h which are included in the &#34;lite&#34; protobuf library. These implementations cover I/O on raw arrays and strings, as well as adaptors which make it easy to implement streams based on traditional streams. Of course, many users will probably want to write their own implementations of these interfaces specific to the particular I/O abstractions they prefer to use, but these should cover the most common cases."><meta itemprop=wordCount content="3445"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="zero_copy_stream_impl_lite.hzero_copy_stream_impl_lite.h#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
namespace google::protobuf::io
This file contains common implementations of the interfaces defined in zero_copy_stream.h which are included in the &#34;lite&#34; protobuf library. These implementations cover I/O on raw arrays and strings, as well as adaptors which make it easy to implement streams based on traditional streams. Of course, many users will probably want to write their own implementations of these interfaces specific to the particular I/O abstractions they prefer to use, but these should cover the most common cases."><link rel=preload href=/scss/main.min.def2cdda5cfcd95d9660c969a68946395435ad5fc75402be473d9995c7e926b3.css as=style><link href=/scss/main.min.def2cdda5cfcd95d9660c969a68946395435ad5fc75402be473d9995c7e926b3.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-5L8P8GRN4Y"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5L8P8GRN4Y")}</script></head><body class=td-page><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar"><a class=navbar-brand href=/><span class="navbar-brand__logo navbar-logo"><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 500 500" style="enable-background:new 0 0 500 500"><g><path style="fill:#fff" d="M116.8525 421.9722c-5.7041.0-10.3442-4.3127-10.3442-9.6129V88.183c0-5.3002 4.6401-9.6117 10.3442-9.6117H320.858c3.0347.0 9.3959.5498 11.7506 2.6302l.3545.3442 58.905 63.2912c2.3101 2.491 2.9202 8.4928 2.9202 11.3184v256.2039c0 5.3002-4.6407 9.6129-10.3436 9.6129H116.8525z"/><g><g><g><path style="fill:#767676" d="M384.4445 423.2066H116.852c-6.3839.0-11.5786-4.8658-11.5786-10.8474V88.1831c0-5.9804 5.1947-10.8461 11.5786-10.8461h204.0062c.377.0 9.2786.0329 12.568 2.9389l.3947.3833 58.9508 63.337c3.2135 3.4652 3.2514 11.7924 3.2514 12.1593v256.2036C396.0231 418.3408 390.8284 423.2066 384.4445 423.2066zM116.5079 411.9189c.0848.0278.1999.0531.3441.0531h267.5925c.1442.0.2581-.0253.3441-.0531V156.1556c-.0076-.9033-.3593-3.7347-.7034-5.0037l-57.6527-61.9416c-1.4651-.3176-4.4533-.6389-5.5742-.6389H116.852c-.143.0-.2594.024-.3441.0531V411.9189zm267.4533-261.149zM327.0321 89.371v.0013V89.371z"/></g></g></g><g><g><path style="fill:#5b7fc0" d="M189.0874 210.1754l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.025 2.454-11.4897 6.4116-15.4473C177.5953 212.627 183.0601 210.1742 189.0874 210.1754zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403S197.0816 234.1722 197.0804 232.033z"/><path style="opacity:.3;fill:#fff" d="M189.0898 210.176c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 212.6276 183.0612 210.176 189.0898 210.176zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 236.239 197.0839 234.2399 197.0839 232.0372z"/><g><defs><path id="SVGID_1_" d="M194.7376 237.6875c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.999 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 234.2399 196.1861 236.239 194.7376 237.6875z"/></defs><clipPath id="SVGID_2_"><use xlink:href="#SVGID_1_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_2_);fill:#fff" d="M190.0704 225.0237c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 225.7247 191.9774 225.0237 190.0704 225.0237z"/><path style="opacity:.13;clip-path:url(#SVGID_2_);fill:#020202" d="M190.0704 225.0237c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 225.7247 191.9774 225.0237 190.0704 225.0237z"/></g><g><defs><path id="SVGID_3_" d="M189.0898 210.176c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 212.6276 183.0612 210.176 189.0898 210.176zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 236.239 197.0839 234.2399 197.0839 232.0372z"/></defs><clipPath id="SVGID_4_"><use xlink:href="#SVGID_3_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_4_);fill:#5b7fc0" d="M172.6595 215.6045c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8612 12.0547.0024 21.8636-9.797 21.8613-21.8612.0024-3.8475-1.0151-7.6326-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 209.1953 176.6171 211.647 172.6595 215.6045z"/></g></g><rect x="198.8952" y="225.1043" style="fill:#5b7fc0" width="122.6266" height="13.8671"/></g><g><path style="fill:#d95140" d="M189.0874 155.7611l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.0249 2.454-11.4897 6.4116-15.4473C177.5953 158.2128 183.0601 155.7599 189.0874 155.7611zm7.993 21.8577c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403C196.2508 181.7667 197.0816 179.758 197.0804 177.6188z"/><path style="opacity:.3;fill:#fff" d="M189.0898 155.7617c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 158.2134 183.0612 155.7617 189.0898 155.7617zm7.9941 21.8613c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 181.8248 197.0839 179.8256 197.0839 177.623z"/><g><defs><path id="SVGID_5_" d="M194.7376 183.2733c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.9989 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 179.8256 196.1861 181.8248 194.7376 183.2733z"/></defs><clipPath id="SVGID_6_"><use xlink:href="#SVGID_5_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_6_);fill:#fff" d="M190.0704 170.6095c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 171.3104 191.9774 170.6095 190.0704 170.6095z"/><path style="opacity:.13;clip-path:url(#SVGID_6_);fill:#020202" d="M190.0704 170.6095c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 171.3104 191.9774 170.6095 190.0704 170.6095z"/></g><g><defs><path id="SVGID_7_" d="M189.0898 155.7617c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 158.2134 183.0612 155.7617 189.0898 155.7617zm7.9941 21.8613c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 181.8248 197.0839 179.8256 197.0839 177.623z"/></defs><clipPath id="SVGID_8_"><use xlink:href="#SVGID_7_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_8_);fill:#d95140" d="M172.6595 161.1903c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8613 12.0547.0024 21.8636-9.797 21.8613-21.8613.0024-3.8474-1.0151-7.6326-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 154.7811 176.6171 157.2327 172.6595 161.1903z"/></g><rect x="198.8952" y="170.69" style="fill:#d95140" width="122.6266" height="13.8671"/></g><g><g><path style="fill:#56a55c" d="M189.5379 264.6147l.0012-.0012c7.7751.0012 15.0294 4.1862 18.932 10.9235 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032-5.8394.0-11.3281-2.2733-15.458-6.4032-4.13-4.13-6.4032-9.6186-6.4056-15.4628.0012-6.0249 2.454-11.4897 6.4116-15.4472C178.0458 267.0663 183.5105 264.6135 189.5379 264.6147zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6538 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403C196.7013 290.6202 197.5321 288.6115 197.5309 286.4723z"/><path style="opacity:.3;fill:#fff" d="M189.5403 264.6153c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8065-21.8612-21.8613.0-6.0285 2.4516-11.492 6.4116-15.452C178.0482 267.0669 183.5117 264.6153 189.5403 264.6153zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.6366 290.6783 197.5344 288.6792 197.5344 286.4765z"/><g><defs><path id="SVGID_9_" d="M195.1881 292.1268c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.9989 7.9942-7.9941 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.5344 288.6792 196.6366 290.6783 195.1881 292.1268z"/></defs><clipPath id="SVGID_10_"><use xlink:href="#SVGID_9_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_10_);fill:#fff" d="M190.5209 279.463c-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7446-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9941 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C194.239 280.164 192.4279 279.463 190.5209 279.463z"/><path style="opacity:.13;clip-path:url(#SVGID_10_);fill:#020202" d="M190.5209 279.463c-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7446-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9941 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C194.239 280.164 192.4279 279.463 190.5209 279.463z"/></g><g><defs><path id="SVGID_11_" d="M189.5403 264.6153c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8065-21.8612-21.8613.0-6.0285 2.4516-11.492 6.4116-15.452C178.0482 267.0669 183.5117 264.6153 189.5403 264.6153zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.6366 290.6783 197.5344 288.6792 197.5344 286.4765z"/></defs><clipPath id="SVGID_12_"><use xlink:href="#SVGID_11_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_12_);fill:#56a55c" d="M173.11 270.0439c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8613 12.0547.0024 21.8636-9.797 21.8613-21.8613.0024-3.8474-1.0151-7.6326-2.9353-10.9462-3.8977-6.7325-11.1497-10.9151-18.926-10.9151C182.5311 263.6346 177.0676 266.0863 173.11 270.0439z"/></g></g><rect x="199.3456" y="279.5436" style="fill:#56a55c" width="122.6266" height="13.8671"/></g><g><g><path style="fill:#f1bc42" d="M189.0874 318.7208l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3305-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.025 2.454-11.4897 6.4116-15.4472C177.5953 321.1724 183.0601 318.7196 189.0874 318.7208zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403S197.0816 342.7176 197.0804 340.5784z"/><path style="opacity:.3;fill:#fff" d="M189.0898 318.7214c7.7763.0 15.0283 4.1826 18.926 10.915 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8612-12.0547.0024-21.8636-9.8065-21.8612-21.8612.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 321.173 183.0612 318.7214 189.0898 318.7214zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 344.7844 197.0839 342.7853 197.0839 340.5826z"/><g><defs><path id="SVGID_13_" d="M194.7376 346.2329c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.999 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 342.7853 196.1861 344.7844 194.7376 346.2329z"/></defs><clipPath id="SVGID_14_"><use xlink:href="#SVGID_13_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_14_);fill:#fff" d="M190.0704 333.5691c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0834 6.1218 2.8788C193.7885 334.2701 191.9774 333.5691 190.0704 333.5691z"/><path style="opacity:.13;clip-path:url(#SVGID_14_);fill:#020202" d="M190.0704 333.5691c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0834 6.1218 2.8788C193.7885 334.2701 191.9774 333.5691 190.0704 333.5691z"/></g><g><defs><path id="SVGID_15_" d="M189.0898 318.7214c7.7763.0 15.0283 4.1826 18.926 10.915 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8612-12.0547.0024-21.8636-9.8065-21.8612-21.8612.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 321.173 183.0612 318.7214 189.0898 318.7214zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 344.7844 197.0839 342.7853 197.0839 340.5826z"/></defs><clipPath id="SVGID_16_"><use xlink:href="#SVGID_15_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_16_);fill:#f1bc42" d="M172.6595 324.15c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8612 12.0547.0024 21.8636-9.797 21.8613-21.8612.0024-3.8474-1.0151-7.6327-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 317.7407 176.6171 320.1924 172.6595 324.15z"/></g></g><rect x="198.8952" y="333.6497" style="fill:#f1bc42" width="122.6266" height="13.8671"/></g></g></svg></span><span class=navbar-brand__name>Protocol Buffers Documentation</span></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"></ul></div><div class="navbar-nav d-none d-lg-block"><div class=td-search><div class=td-search__icon></div><input type=search class="td-search__input form-control td-search-input" placeholder="Search this site…" aria-label="Search this site…" autocomplete=off></div></div></nav></header><div class="container-fluid td-default td-outer"><main role=main class=td-main><html devsite><head><title>zero_copy_stream_impl_lite.h</title><meta name=project_path value=/protocol-buffers/_project.yaml><meta name=book_path value=/protocol-buffers/_book.yaml></head><body><h1>zero_copy_stream_impl_lite.h</h1><p><code>#include &lt;google/protobuf/io/zero_copy_stream_impl_lite.h><br>namespace <a href=#google.protobuf.io>google::protobuf::io</a></code></p><p>This file contains common implementations of the interfaces defined in <a href=google.protobuf.io.zero_copy_stream>zero_copy_stream.h</a> which are included in the "lite" protobuf library.</p><p>These implementations cover I/O on raw arrays and strings, as well as adaptors which make it easy to implement streams based on traditional streams. Of course, many users will probably want to write their own implementations of these interfaces specific to the particular I/O abstractions they prefer to use, but these should cover the most common cases.</p><table width=100%><tr><th colspan=2><h3 style=margin-top:4px>Classes in this file</h3></th></tr><tr><td><div><code><a href=#ArrayInputStream>ArrayInputStream</a></code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>A <a href=google.protobuf.io.zero_copy_stream#ZeroCopyInputStream>ZeroCopyInputStream</a> backed by an in-memory array of bytes.</div></td></tr><tr><td><div><code><a href=#ArrayOutputStream>ArrayOutputStream</a></code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>A <a href=google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream>ZeroCopyOutputStream</a> backed by an in-memory array of bytes.</div></td></tr><tr><td><div><code><a href=#StringOutputStream>StringOutputStream</a></code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>A <a href=google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream>ZeroCopyOutputStream</a> which appends bytes to a string.</div></td></tr><tr><td><div><code><a href=#CopyingInputStream>CopyingInputStream</a></code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>A generic traditional input stream interface.</div></td></tr><tr><td><div><code><a href=#CopyingInputStreamAdaptor>CopyingInputStreamAdaptor</a></code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>A <a href=google.protobuf.io.zero_copy_stream#ZeroCopyInputStream>ZeroCopyInputStream</a> which reads from a <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingInputStream>CopyingInputStream</a>.</div></td></tr><tr><td><div><code><a href=#CopyingOutputStream>CopyingOutputStream</a></code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>A generic traditional output stream interface.</div></td></tr><tr><td><div><code><a href=#CopyingOutputStreamAdaptor>CopyingOutputStreamAdaptor</a></code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>A <a href=google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream>ZeroCopyOutputStream</a> which writes to a <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingOutputStream>CopyingOutputStream</a>.</div></td></tr><tr><td><div><code><a href=#LimitingInputStream>LimitingInputStream</a></code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>A <a href=google.protobuf.io.zero_copy_stream#ZeroCopyInputStream>ZeroCopyInputStream</a> which wraps some other stream and limits it to a particular byte count.</div></td></tr></table><table><tr><th colspan=2><h3 style=margin-top:4px>File Members</h3><div style=font-style:italic;font-weight:400>These definitions are not part of any class.</div></th></tr><tr><td style=border-right-width:0;text-align:right><code>char *</code></td><td style=border-left-width:0 id=mutable_string_data><div style=padding-left:16px;text-indent:-16px><code><b>mutable_string_data</b>(std::string * s)</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Return a pointer to mutable characters underlying the given string. <a href=#mutable_string_data.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>std::pair&lt; char *, bool ></code></td><td style=border-left-width:0 id=as_string_data><div style=padding-left:16px;text-indent:-16px><code><b>as_string_data</b>(std::string * s)</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>as_string_data(s) is equivalent to ({ char* p = mutable_string_data(s); make_pair(p, p != NULL); }) Sometimes it's faster: in some scenarios p cannot be NULL, and then the code can avoid that check.</div></td></tr></table><hr><h3 id=mutable_string_data.details><code>char * io::mutable_string_data(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string * s)</code></h3><div style=margin-left:16px><p>Return a pointer to mutable characters underlying the given string.</p><p>The return value is valid until the next time the string is resized. We trust the caller to treat the return value as an array of length s->size().</p></div><h2 id=ArrayInputStream>class ArrayInputStream: public <a href=google.protobuf.io.zero_copy_stream#ZeroCopyInputStream>ZeroCopyInputStream</a></h2><p><code>#include &lt;<a href=#>google/protobuf/io/zero_copy_stream_impl_lite.h</a>><br>namespace <a href=#google.protobuf.io>google::protobuf::io</a></code></p><p>A <a href=google.protobuf.io.zero_copy_stream#ZeroCopyInputStream>ZeroCopyInputStream</a> backed by an in-memory array of bytes.</p><table><tr><th colspan=2><h3 style=margin-top:4px>Members</h3></th></tr><tr><td style=border-right-width:0;text-align:right><code></code></td><td style=border-left-width:0 id=ArrayInputStream.ArrayInputStream><div style=padding-left:16px;text-indent:-16px><code><b>ArrayInputStream</b>(const void * data, int size, int block_size = -1)</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Create an InputStream that returns the bytes pointed to by "data". <a href=#ArrayInputStream.ArrayInputStream.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code></code></td><td style=border-left-width:0 id=ArrayInputStream.~ArrayInputStream><div style=padding-left:16px;text-indent:-16px><code><b>~ArrayInputStream</b>()</code></div></td></tr><tr><th colspan=2><h3 style=margin-top:4px;margin-bottom:4px>implements <a href=google.protobuf.io.zero_copy_stream#ZeroCopyInputStream>ZeroCopyInputStream</a></h3><div style=font-style:italic;font-weight:400></div></th></tr><tr><td style=border-right-width:0;text-align:right><code>virtual bool</code></td><td style=border-left-width:0 id=ArrayInputStream.Next><div style=padding-left:16px;text-indent:-16px><code><b>Next</b>(const void ** data, int * size)</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Obtains a chunk of data from the stream. <a href=#ArrayInputStream.Next.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual void</code></td><td style=border-left-width:0 id=ArrayInputStream.BackUp><div style=padding-left:16px;text-indent:-16px><code><b>BackUp</b>(int count)</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Backs up a number of bytes, so that the next call to <a href=google.protobuf.io.zero_copy_stream_impl_lite#ArrayInputStream.Next>Next()</a> returns data again that was already returned by the last call to <a href=google.protobuf.io.zero_copy_stream_impl_lite#ArrayInputStream.Next>Next()</a>. <a href=#ArrayInputStream.BackUp.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual bool</code></td><td style=border-left-width:0 id=ArrayInputStream.Skip><div style=padding-left:16px;text-indent:-16px><code><b>Skip</b>(int count)</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Skips a number of bytes. <a href=#ArrayInputStream.Skip.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual int64_t</code></td><td style=border-left-width:0 id=ArrayInputStream.ByteCount><div style=padding-left:16px;text-indent:-16px><code><b>ByteCount</b>() const</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Returns the total number of bytes read since this object was created.</div></td></tr></table><hr><h3 id=ArrayInputStream.ArrayInputStream.details><code>ArrayInputStream::ArrayInputStream(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const void * data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int block_size = -1)</code></h3><div style=margin-left:16px><p>Create an InputStream that returns the bytes pointed to by "data".</p><p>"data" remains the property of the caller but must remain valid until the stream is destroyed. If a block_size is given, calls to <a href=google.protobuf.io.zero_copy_stream_impl_lite#ArrayInputStream.Next>Next()</a> will return data blocks no larger than the given size. Otherwise, the first call to <a href=google.protobuf.io.zero_copy_stream_impl_lite#ArrayInputStream.Next>Next()</a> returns the entire array. block_size is mainly useful for testing; in production you would probably never want to set it.</p></div><hr><h3 id=ArrayInputStream.Next.details><code>virtual bool ArrayInputStream::Next(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const void ** data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int * size)</code></h3><div style=margin-left:16px><p>Obtains a chunk of data from the stream.</p><p>Preconditions:</p><ul><li>"size" and "data" are not NULL.</li></ul><p>Postconditions:</p><ul><li>If the returned value is false, there is no more data to return or an error occurred. All errors are permanent.</li><li>Otherwise, "size" points to the actual number of bytes read and "data" points to a pointer to a buffer containing these bytes.</li><li>Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed.</li><li>It is legal for the returned buffer to have zero size, as long as repeatedly calling <a href=google.protobuf.io.zero_copy_stream_impl_lite#ArrayInputStream.Next>Next()</a> eventually yields a buffer with non-zero size.</li></ul></div><hr><h3 id=ArrayInputStream.BackUp.details><code>virtual void ArrayInputStream::BackUp(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style=margin-left:16px><p>Backs up a number of bytes, so that the next call to <a href=google.protobuf.io.zero_copy_stream_impl_lite#ArrayInputStream.Next>Next()</a> returns data again that was already returned by the last call to <a href=google.protobuf.io.zero_copy_stream_impl_lite#ArrayInputStream.Next>Next()</a>.</p><p>This is useful when writing procedures that are only supposed to read up to a certain point in the input, then return. If <a href=google.protobuf.io.zero_copy_stream_impl_lite#ArrayInputStream.Next>Next()</a> returns a buffer that goes beyond what you wanted to read, you can use <a href=google.protobuf.io.zero_copy_stream_impl_lite#ArrayInputStream.BackUp>BackUp()</a> to return to the point where you intended to finish.</p><p>Preconditions:</p><ul><li>The last method called must have been <a href=google.protobuf.io.zero_copy_stream_impl_lite#ArrayInputStream.Next>Next()</a>.</li><li>count must be less than or equal to the size of the last buffer returned by <a href=google.protobuf.io.zero_copy_stream_impl_lite#ArrayInputStream.Next>Next()</a>.</li></ul><p>Postconditions:</p><ul><li>The last "count" bytes of the last buffer returned by <a href=google.protobuf.io.zero_copy_stream_impl_lite#ArrayInputStream.Next>Next()</a> will be pushed back into the stream. Subsequent calls to <a href=google.protobuf.io.zero_copy_stream_impl_lite#ArrayInputStream.Next>Next()</a> will return the same data again before producing new data.</li></ul></div><hr><h3 id=ArrayInputStream.Skip.details><code>virtual bool ArrayInputStream::Skip(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style=margin-left:16px><p>Skips a number of bytes.</p><p>Returns false if the end of the stream is reached or some input error occurred. In the end-of-stream case, the stream is advanced to the end of the stream (so <a href=google.protobuf.io.zero_copy_stream_impl_lite#ArrayInputStream.ByteCount>ByteCount()</a> will return the total size of the stream).</p></div><h2 id=ArrayOutputStream>class ArrayOutputStream: public <a href=google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream>ZeroCopyOutputStream</a></h2><p><code>#include &lt;<a href=#>google/protobuf/io/zero_copy_stream_impl_lite.h</a>><br>namespace <a href=#google.protobuf.io>google::protobuf::io</a></code></p><p>A <a href=google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream>ZeroCopyOutputStream</a> backed by an in-memory array of bytes.</p><table><tr><th colspan=2><h3 style=margin-top:4px>Members</h3></th></tr><tr><td style=border-right-width:0;text-align:right><code></code></td><td style=border-left-width:0 id=ArrayOutputStream.ArrayOutputStream><div style=padding-left:16px;text-indent:-16px><code><b>ArrayOutputStream</b>(void * data, int size, int block_size = -1)</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Create an OutputStream that writes to the bytes pointed to by "data". <a href=#ArrayOutputStream.ArrayOutputStream.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code></code></td><td style=border-left-width:0 id=ArrayOutputStream.~ArrayOutputStream><div style=padding-left:16px;text-indent:-16px><code><b>~ArrayOutputStream</b>()</code></div></td></tr><tr><th colspan=2><h3 style=margin-top:4px;margin-bottom:4px>implements <a href=google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream>ZeroCopyOutputStream</a></h3><div style=font-style:italic;font-weight:400></div></th></tr><tr><td style=border-right-width:0;text-align:right><code>virtual bool</code></td><td style=border-left-width:0 id=ArrayOutputStream.Next><div style=padding-left:16px;text-indent:-16px><code><b>Next</b>(void ** data, int * size)</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Obtains a buffer into which data can be written. <a href=#ArrayOutputStream.Next.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual void</code></td><td style=border-left-width:0 id=ArrayOutputStream.BackUp><div style=padding-left:16px;text-indent:-16px><code><b>BackUp</b>(int count)</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Backs up a number of bytes, so that the end of the last buffer returned by <a href=google.protobuf.io.zero_copy_stream_impl_lite#ArrayOutputStream.Next>Next()</a> is not actually written. <a href=#ArrayOutputStream.BackUp.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual int64_t</code></td><td style=border-left-width:0 id=ArrayOutputStream.ByteCount><div style=padding-left:16px;text-indent:-16px><code><b>ByteCount</b>() const</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Returns the total number of bytes written since this object was created.</div></td></tr></table><hr><h3 id=ArrayOutputStream.ArrayOutputStream.details><code>ArrayOutputStream::ArrayOutputStream(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void * data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int block_size = -1)</code></h3><div style=margin-left:16px><p>Create an OutputStream that writes to the bytes pointed to by "data".</p><p>"data" remains the property of the caller but must remain valid until the stream is destroyed. If a block_size is given, calls to <a href=google.protobuf.io.zero_copy_stream_impl_lite#ArrayOutputStream.Next>Next()</a> will return data blocks no larger than the given size. Otherwise, the first call to <a href=google.protobuf.io.zero_copy_stream_impl_lite#ArrayOutputStream.Next>Next()</a> returns the entire array. block_size is mainly useful for testing; in production you would probably never want to set it.</p></div><hr><h3 id=ArrayOutputStream.Next.details><code>virtual bool ArrayOutputStream::Next(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void ** data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int * size)</code></h3><div style=margin-left:16px><p>Obtains a buffer into which data can be written.</p><p>Any data written into this buffer will eventually (maybe instantly, maybe later on) be written to the output.</p><p>Preconditions:</p><ul><li>"size" and "data" are not NULL.</li></ul><p>Postconditions:</p><ul><li>If the returned value is false, an error occurred. All errors are permanent.</li><li>Otherwise, "size" points to the actual number of bytes in the buffer and "data" points to the buffer.</li><li>Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed.</li><li>Any data which the caller stores in this buffer will eventually be written to the output (unless <a href=google.protobuf.io.zero_copy_stream_impl_lite#ArrayOutputStream.BackUp>BackUp()</a> is called).</li><li>It is legal for the returned buffer to have zero size, as long as repeatedly calling <a href=google.protobuf.io.zero_copy_stream_impl_lite#ArrayOutputStream.Next>Next()</a> eventually yields a buffer with non-zero size.</li></ul></div><hr><h3 id=ArrayOutputStream.BackUp.details><code>virtual void ArrayOutputStream::BackUp(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style=margin-left:16px><p>Backs up a number of bytes, so that the end of the last buffer returned by <a href=google.protobuf.io.zero_copy_stream_impl_lite#ArrayOutputStream.Next>Next()</a> is not actually written.</p><p>This is needed when you finish writing all the data you want to write, but the last buffer was bigger than you needed. You don't want to write a bunch of garbage after the end of your data, so you use <a href=google.protobuf.io.zero_copy_stream_impl_lite#ArrayOutputStream.BackUp>BackUp()</a> to back up.</p><p>Preconditions:</p><ul><li>The last method called must have been <a href=google.protobuf.io.zero_copy_stream_impl_lite#ArrayOutputStream.Next>Next()</a>.</li><li>count must be less than or equal to the size of the last buffer returned by <a href=google.protobuf.io.zero_copy_stream_impl_lite#ArrayOutputStream.Next>Next()</a>.</li><li>The caller must not have written anything to the last "count" bytes of that buffer.</li></ul><p>Postconditions:</p><ul><li>The last "count" bytes of the last buffer returned by <a href=google.protobuf.io.zero_copy_stream_impl_lite#ArrayOutputStream.Next>Next()</a> will be ignored.</li></ul></div><h2 id=StringOutputStream>class StringOutputStream: public <a href=google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream>ZeroCopyOutputStream</a></h2><p><code>#include &lt;<a href=#>google/protobuf/io/zero_copy_stream_impl_lite.h</a>><br>namespace <a href=#google.protobuf.io>google::protobuf::io</a></code></p><p>A <a href=google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream>ZeroCopyOutputStream</a> which appends bytes to a string.</p><table><tr><th colspan=2><h3 style=margin-top:4px>Members</h3></th></tr><tr><td style=border-right-width:0;text-align:right><code>explicit</code></td><td style=border-left-width:0 id=StringOutputStream.StringOutputStream><div style=padding-left:16px;text-indent:-16px><code><b>StringOutputStream</b>(std::string * target)</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Create a <a href=google.protobuf.io.zero_copy_stream_impl_lite#StringOutputStream>StringOutputStream</a> which appends bytes to the given string. <a href=#StringOutputStream.StringOutputStream.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code></code></td><td style=border-left-width:0 id=StringOutputStream.~StringOutputStream><div style=padding-left:16px;text-indent:-16px><code><b>~StringOutputStream</b>()</code></div></td></tr><tr><th colspan=2><h3 style=margin-top:4px;margin-bottom:4px>implements <a href=google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream>ZeroCopyOutputStream</a></h3><div style=font-style:italic;font-weight:400></div></th></tr><tr><td style=border-right-width:0;text-align:right><code>virtual bool</code></td><td style=border-left-width:0 id=StringOutputStream.Next><div style=padding-left:16px;text-indent:-16px><code><b>Next</b>(void ** data, int * size)</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Obtains a buffer into which data can be written. <a href=#StringOutputStream.Next.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual void</code></td><td style=border-left-width:0 id=StringOutputStream.BackUp><div style=padding-left:16px;text-indent:-16px><code><b>BackUp</b>(int count)</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Backs up a number of bytes, so that the end of the last buffer returned by <a href=google.protobuf.io.zero_copy_stream_impl_lite#StringOutputStream.Next>Next()</a> is not actually written. <a href=#StringOutputStream.BackUp.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual int64_t</code></td><td style=border-left-width:0 id=StringOutputStream.ByteCount><div style=padding-left:16px;text-indent:-16px><code><b>ByteCount</b>() const</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Returns the total number of bytes written since this object was created.</div></td></tr></table><hr><h3 id=StringOutputStream.StringOutputStream.details><code>explicit StringOutputStream::StringOutputStream(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::string * target)</code></h3><div style=margin-left:16px><p>Create a <a href=google.protobuf.io.zero_copy_stream_impl_lite#StringOutputStream>StringOutputStream</a> which appends bytes to the given string.</p><p>The string remains property of the caller, but it is mutated in arbitrary ways and MUST NOT be accessed in any way until you're done with the stream. Either be sure there's no further usage, or (safest) destroy the stream before using the contents.</p><p>Hint: If you call target->reserve(n) before creating the stream, the first call to <a href=google.protobuf.io.zero_copy_stream_impl_lite#StringOutputStream.Next>Next()</a> will return at least n bytes of buffer space.</p></div><hr><h3 id=StringOutputStream.Next.details><code>virtual bool StringOutputStream::Next(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void ** data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int * size)</code></h3><div style=margin-left:16px><p>Obtains a buffer into which data can be written.</p><p>Any data written into this buffer will eventually (maybe instantly, maybe later on) be written to the output.</p><p>Preconditions:</p><ul><li>"size" and "data" are not NULL.</li></ul><p>Postconditions:</p><ul><li>If the returned value is false, an error occurred. All errors are permanent.</li><li>Otherwise, "size" points to the actual number of bytes in the buffer and "data" points to the buffer.</li><li>Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed.</li><li>Any data which the caller stores in this buffer will eventually be written to the output (unless <a href=google.protobuf.io.zero_copy_stream_impl_lite#StringOutputStream.BackUp>BackUp()</a> is called).</li><li>It is legal for the returned buffer to have zero size, as long as repeatedly calling <a href=google.protobuf.io.zero_copy_stream_impl_lite#StringOutputStream.Next>Next()</a> eventually yields a buffer with non-zero size.</li></ul></div><hr><h3 id=StringOutputStream.BackUp.details><code>virtual void StringOutputStream::BackUp(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style=margin-left:16px><p>Backs up a number of bytes, so that the end of the last buffer returned by <a href=google.protobuf.io.zero_copy_stream_impl_lite#StringOutputStream.Next>Next()</a> is not actually written.</p><p>This is needed when you finish writing all the data you want to write, but the last buffer was bigger than you needed. You don't want to write a bunch of garbage after the end of your data, so you use <a href=google.protobuf.io.zero_copy_stream_impl_lite#StringOutputStream.BackUp>BackUp()</a> to back up.</p><p>Preconditions:</p><ul><li>The last method called must have been <a href=google.protobuf.io.zero_copy_stream_impl_lite#StringOutputStream.Next>Next()</a>.</li><li>count must be less than or equal to the size of the last buffer returned by <a href=google.protobuf.io.zero_copy_stream_impl_lite#StringOutputStream.Next>Next()</a>.</li><li>The caller must not have written anything to the last "count" bytes of that buffer.</li></ul><p>Postconditions:</p><ul><li>The last "count" bytes of the last buffer returned by <a href=google.protobuf.io.zero_copy_stream_impl_lite#StringOutputStream.Next>Next()</a> will be ignored.</li></ul></div><h2 id=CopyingInputStream>class CopyingInputStream</h2><p><code>#include &lt;<a href=#>google/protobuf/io/zero_copy_stream_impl_lite.h</a>><br>namespace <a href=#google.protobuf.io>google::protobuf::io</a></code></p><p>A generic traditional input stream interface.</p><p>Lots of traditional input streams (e.g. file descriptors, C stdio streams, and C++ iostreams) expose an interface where every read involves copying bytes into a buffer. If you want to take such an interface and make a <a href=google.protobuf.io.zero_copy_stream#ZeroCopyInputStream>ZeroCopyInputStream</a> based on it, simply implement <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingInputStream>CopyingInputStream</a> and then use <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingInputStreamAdaptor>CopyingInputStreamAdaptor</a>.</p><p><a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingInputStream>CopyingInputStream</a> implementations should avoid buffering if possible. <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingInputStreamAdaptor>CopyingInputStreamAdaptor</a> does its own buffering and will read data in large blocks.</p><table><tr><th colspan=2><h3 style=margin-top:4px>Members</h3></th></tr><tr><td style=border-right-width:0;text-align:right><code>virtual</code></td><td style=border-left-width:0 id=CopyingInputStream.~CopyingInputStream><div style=padding-left:16px;text-indent:-16px><code><b>~CopyingInputStream</b>()</code></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual int</code></td><td style=border-left-width:0 id=CopyingInputStream.Read><div style=padding-left:16px;text-indent:-16px><code><b>Read</b>(void * buffer, int size) = 0</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Reads up to "size" bytes into the given buffer. <a href=#CopyingInputStream.Read.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual int</code></td><td style=border-left-width:0 id=CopyingInputStream.Skip><div style=padding-left:16px;text-indent:-16px><code><b>Skip</b>(int count)</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Skips the next "count" bytes of input. <a href=#CopyingInputStream.Skip.details>more...</a></div></td></tr></table><hr><h3 id=CopyingInputStream.Read.details><code>virtual int CopyingInputStream::Read(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void * buffer,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size) = 0</code></h3><div style=margin-left:16px><p>Reads up to "size" bytes into the given buffer.</p><p>Returns the number of bytes read. <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingInputStream.Read>Read()</a> waits until at least one byte is available, or returns zero if no bytes will ever become available (EOF), or -1 if a permanent read error occurred.</p></div><hr><h3 id=CopyingInputStream.Skip.details><code>virtual int CopyingInputStream::Skip(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style=margin-left:16px><p>Skips the next "count" bytes of input.</p><p>Returns the number of bytes actually skipped. This will always be exactly equal to "count" unless EOF was reached or a permanent read error occurred.</p><p>The default implementation just repeatedly calls <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingInputStream.Read>Read()</a> into a scratch buffer.</p></div><h2 id=CopyingInputStreamAdaptor>class CopyingInputStreamAdaptor: public <a href=google.protobuf.io.zero_copy_stream#ZeroCopyInputStream>ZeroCopyInputStream</a></h2><p><code>#include &lt;<a href=#>google/protobuf/io/zero_copy_stream_impl_lite.h</a>><br>namespace <a href=#google.protobuf.io>google::protobuf::io</a></code></p><p>A <a href=google.protobuf.io.zero_copy_stream#ZeroCopyInputStream>ZeroCopyInputStream</a> which reads from a <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingInputStream>CopyingInputStream</a>.</p><p>This is useful for implementing ZeroCopyInputStreams that read from traditional streams. Note that this class is not really zero-copy.</p><p>If you want to read from file descriptors or C++ istreams, this is already implemented for you: use <a href=google.protobuf.io.zero_copy_stream_impl#FileInputStream>FileInputStream</a> or <a href=google.protobuf.io.zero_copy_stream_impl#IstreamInputStream>IstreamInputStream</a> respectively.</p><table><tr><th colspan=2><h3 style=margin-top:4px>Members</h3></th></tr><tr><td style=border-right-width:0;text-align:right><code>explicit</code></td><td style=border-left-width:0 id=CopyingInputStreamAdaptor.CopyingInputStreamAdaptor><div style=padding-left:16px;text-indent:-16px><code><b>CopyingInputStreamAdaptor</b>(<a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingInputStream>CopyingInputStream</a> * copying_stream, int block_size = -1)</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Creates a stream that reads from the given <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingInputStream>CopyingInputStream</a>. <a href=#CopyingInputStreamAdaptor.CopyingInputStreamAdaptor.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code></code></td><td style=border-left-width:0 id=CopyingInputStreamAdaptor.~CopyingInputStreamAdaptor><div style=padding-left:16px;text-indent:-16px><code><b>~CopyingInputStreamAdaptor</b>()</code></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>void</code></td><td style=border-left-width:0 id=CopyingInputStreamAdaptor.SetOwnsCopyingStream><div style=padding-left:16px;text-indent:-16px><code><b>SetOwnsCopyingStream</b>(bool value)</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Call SetOwnsCopyingStream(true) to tell the <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingInputStreamAdaptor>CopyingInputStreamAdaptor</a> to delete the underlying <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingInputStream>CopyingInputStream</a> when it is destroyed.</div></td></tr><tr><th colspan=2><h3 style=margin-top:4px;margin-bottom:4px>implements <a href=google.protobuf.io.zero_copy_stream#ZeroCopyInputStream>ZeroCopyInputStream</a></h3><div style=font-style:italic;font-weight:400></div></th></tr><tr><td style=border-right-width:0;text-align:right><code>virtual bool</code></td><td style=border-left-width:0 id=CopyingInputStreamAdaptor.Next><div style=padding-left:16px;text-indent:-16px><code><b>Next</b>(const void ** data, int * size)</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Obtains a chunk of data from the stream. <a href=#CopyingInputStreamAdaptor.Next.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual void</code></td><td style=border-left-width:0 id=CopyingInputStreamAdaptor.BackUp><div style=padding-left:16px;text-indent:-16px><code><b>BackUp</b>(int count)</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Backs up a number of bytes, so that the next call to <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingInputStreamAdaptor.Next>Next()</a> returns data again that was already returned by the last call to <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingInputStreamAdaptor.Next>Next()</a>. <a href=#CopyingInputStreamAdaptor.BackUp.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual bool</code></td><td style=border-left-width:0 id=CopyingInputStreamAdaptor.Skip><div style=padding-left:16px;text-indent:-16px><code><b>Skip</b>(int count)</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Skips a number of bytes. <a href=#CopyingInputStreamAdaptor.Skip.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual int64_t</code></td><td style=border-left-width:0 id=CopyingInputStreamAdaptor.ByteCount><div style=padding-left:16px;text-indent:-16px><code><b>ByteCount</b>() const</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Returns the total number of bytes read since this object was created.</div></td></tr></table><hr><h3 id=CopyingInputStreamAdaptor.CopyingInputStreamAdaptor.details><code>explicit CopyingInputStreamAdaptor::CopyingInputStreamAdaptor(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingInputStream>CopyingInputStream</a> * copying_stream,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int block_size = -1)</code></h3><div style=margin-left:16px><p>Creates a stream that reads from the given <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingInputStream>CopyingInputStream</a>.</p><p>If a block_size is given, it specifies the number of bytes that should be read and returned with each call to <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingInputStreamAdaptor.Next>Next()</a>. Otherwise, a reasonable default is used. The caller retains ownership of copying_stream unless SetOwnsCopyingStream(true) is called.</p></div><hr><h3 id=CopyingInputStreamAdaptor.Next.details><code>virtual bool CopyingInputStreamAdaptor::Next(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const void ** data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int * size)</code></h3><div style=margin-left:16px><p>Obtains a chunk of data from the stream.</p><p>Preconditions:</p><ul><li>"size" and "data" are not NULL.</li></ul><p>Postconditions:</p><ul><li>If the returned value is false, there is no more data to return or an error occurred. All errors are permanent.</li><li>Otherwise, "size" points to the actual number of bytes read and "data" points to a pointer to a buffer containing these bytes.</li><li>Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed.</li><li>It is legal for the returned buffer to have zero size, as long as repeatedly calling <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingInputStreamAdaptor.Next>Next()</a> eventually yields a buffer with non-zero size.</li></ul></div><hr><h3 id=CopyingInputStreamAdaptor.BackUp.details><code>virtual void CopyingInputStreamAdaptor::BackUp(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style=margin-left:16px><p>Backs up a number of bytes, so that the next call to <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingInputStreamAdaptor.Next>Next()</a> returns data again that was already returned by the last call to <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingInputStreamAdaptor.Next>Next()</a>.</p><p>This is useful when writing procedures that are only supposed to read up to a certain point in the input, then return. If <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingInputStreamAdaptor.Next>Next()</a> returns a buffer that goes beyond what you wanted to read, you can use <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingInputStreamAdaptor.BackUp>BackUp()</a> to return to the point where you intended to finish.</p><p>Preconditions:</p><ul><li>The last method called must have been <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingInputStreamAdaptor.Next>Next()</a>.</li><li>count must be less than or equal to the size of the last buffer returned by <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingInputStreamAdaptor.Next>Next()</a>.</li></ul><p>Postconditions:</p><ul><li>The last "count" bytes of the last buffer returned by <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingInputStreamAdaptor.Next>Next()</a> will be pushed back into the stream. Subsequent calls to <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingInputStreamAdaptor.Next>Next()</a> will return the same data again before producing new data.</li></ul></div><hr><h3 id=CopyingInputStreamAdaptor.Skip.details><code>virtual bool CopyingInputStreamAdaptor::Skip(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style=margin-left:16px><p>Skips a number of bytes.</p><p>Returns false if the end of the stream is reached or some input error occurred. In the end-of-stream case, the stream is advanced to the end of the stream (so <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingInputStreamAdaptor.ByteCount>ByteCount()</a> will return the total size of the stream).</p></div><h2 id=CopyingOutputStream>class CopyingOutputStream</h2><p><code>#include &lt;<a href=#>google/protobuf/io/zero_copy_stream_impl_lite.h</a>><br>namespace <a href=#google.protobuf.io>google::protobuf::io</a></code></p><p>A generic traditional output stream interface.</p><p>Lots of traditional output streams (e.g. file descriptors, C stdio streams, and C++ iostreams) expose an interface where every write involves copying bytes from a buffer. If you want to take such an interface and make a <a href=google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream>ZeroCopyOutputStream</a> based on it, simply implement <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingOutputStream>CopyingOutputStream</a> and then use <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingOutputStreamAdaptor>CopyingOutputStreamAdaptor</a>.</p><p><a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingOutputStream>CopyingOutputStream</a> implementations should avoid buffering if possible. <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingOutputStreamAdaptor>CopyingOutputStreamAdaptor</a> does its own buffering and will write data in large blocks.</p><table><tr><th colspan=2><h3 style=margin-top:4px>Members</h3></th></tr><tr><td style=border-right-width:0;text-align:right><code>virtual</code></td><td style=border-left-width:0 id=CopyingOutputStream.~CopyingOutputStream><div style=padding-left:16px;text-indent:-16px><code><b>~CopyingOutputStream</b>()</code></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual bool</code></td><td style=border-left-width:0 id=CopyingOutputStream.Write><div style=padding-left:16px;text-indent:-16px><code><b>Write</b>(const void * buffer, int size) = 0</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Writes "size" bytes from the given buffer to the output. <a href=#CopyingOutputStream.Write.details>more...</a></div></td></tr></table><hr><h3 id=CopyingOutputStream.Write.details><code>virtual bool CopyingOutputStream::Write(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const void * buffer,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size) = 0</code></h3><div style=margin-left:16px><p>Writes "size" bytes from the given buffer to the output.</p><p>Returns true if successful, false on a write error.</p></div><h2 id=CopyingOutputStreamAdaptor>class CopyingOutputStreamAdaptor: public <a href=google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream>ZeroCopyOutputStream</a></h2><p><code>#include &lt;<a href=#>google/protobuf/io/zero_copy_stream_impl_lite.h</a>><br>namespace <a href=#google.protobuf.io>google::protobuf::io</a></code></p><p>A <a href=google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream>ZeroCopyOutputStream</a> which writes to a <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingOutputStream>CopyingOutputStream</a>.</p><p>This is useful for implementing ZeroCopyOutputStreams that write to traditional streams. Note that this class is not really zero-copy.</p><p>If you want to write to file descriptors or C++ ostreams, this is already implemented for you: use <a href=google.protobuf.io.zero_copy_stream_impl#FileOutputStream>FileOutputStream</a> or <a href=google.protobuf.io.zero_copy_stream_impl#OstreamOutputStream>OstreamOutputStream</a> respectively.</p><p>Known subclasses:</p><ul><li><code><a href=google.protobuf.io.zero_copy_stream_impl#FileOutputStream>FileOutputStream</a></code></li></ul><table><tr><th colspan=2><h3 style=margin-top:4px>Members</h3></th></tr><tr><td style=border-right-width:0;text-align:right><code>explicit</code></td><td style=border-left-width:0 id=CopyingOutputStreamAdaptor.CopyingOutputStreamAdaptor><div style=padding-left:16px;text-indent:-16px><code><b>CopyingOutputStreamAdaptor</b>(<a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingOutputStream>CopyingOutputStream</a> * copying_stream, int block_size = -1)</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Creates a stream that writes to the given Unix file descriptor. <a href=#CopyingOutputStreamAdaptor.CopyingOutputStreamAdaptor.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code></code></td><td style=border-left-width:0 id=CopyingOutputStreamAdaptor.~CopyingOutputStreamAdaptor><div style=padding-left:16px;text-indent:-16px><code><b>~CopyingOutputStreamAdaptor</b>()</code></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>bool</code></td><td style=border-left-width:0 id=CopyingOutputStreamAdaptor.Flush><div style=padding-left:16px;text-indent:-16px><code><b>Flush</b>()</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Writes all pending data to the underlying stream. <a href=#CopyingOutputStreamAdaptor.Flush.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>void</code></td><td style=border-left-width:0 id=CopyingOutputStreamAdaptor.SetOwnsCopyingStream><div style=padding-left:16px;text-indent:-16px><code><b>SetOwnsCopyingStream</b>(bool value)</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Call SetOwnsCopyingStream(true) to tell the <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingOutputStreamAdaptor>CopyingOutputStreamAdaptor</a> to delete the underlying <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingOutputStream>CopyingOutputStream</a> when it is destroyed.</div></td></tr><tr><th colspan=2><h3 style=margin-top:4px;margin-bottom:4px>implements <a href=google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream>ZeroCopyOutputStream</a></h3><div style=font-style:italic;font-weight:400></div></th></tr><tr><td style=border-right-width:0;text-align:right><code>virtual bool</code></td><td style=border-left-width:0 id=CopyingOutputStreamAdaptor.Next><div style=padding-left:16px;text-indent:-16px><code><b>Next</b>(void ** data, int * size)</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Obtains a buffer into which data can be written. <a href=#CopyingOutputStreamAdaptor.Next.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual void</code></td><td style=border-left-width:0 id=CopyingOutputStreamAdaptor.BackUp><div style=padding-left:16px;text-indent:-16px><code><b>BackUp</b>(int count)</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Backs up a number of bytes, so that the end of the last buffer returned by <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingOutputStreamAdaptor.Next>Next()</a> is not actually written. <a href=#CopyingOutputStreamAdaptor.BackUp.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual int64_t</code></td><td style=border-left-width:0 id=CopyingOutputStreamAdaptor.ByteCount><div style=padding-left:16px;text-indent:-16px><code><b>ByteCount</b>() const</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Returns the total number of bytes written since this object was created.</div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual bool</code></td><td style=border-left-width:0 id=CopyingOutputStreamAdaptor.WriteAliasedRaw><div style=padding-left:16px;text-indent:-16px><code><b>WriteAliasedRaw</b>(const void * data, int size)</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Write a given chunk of data to the output. <a href=#CopyingOutputStreamAdaptor.WriteAliasedRaw.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual bool</code></td><td style=border-left-width:0 id=CopyingOutputStreamAdaptor.AllowsAliasing><div style=padding-left:16px;text-indent:-16px><code><b>AllowsAliasing</b>() const</code></div></td></tr></table><hr><h3 id=CopyingOutputStreamAdaptor.CopyingOutputStreamAdaptor.details><code>explicit CopyingOutputStreamAdaptor::CopyingOutputStreamAdaptor(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingOutputStream>CopyingOutputStream</a> * copying_stream,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int block_size = -1)</code></h3><div style=margin-left:16px><p>Creates a stream that writes to the given Unix file descriptor.</p><p>If a block_size is given, it specifies the size of the buffers that should be returned by <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingOutputStreamAdaptor.Next>Next()</a>. Otherwise, a reasonable default is used.</p></div><hr><h3 id=CopyingOutputStreamAdaptor.Flush.details><code>bool CopyingOutputStreamAdaptor::Flush()</code></h3><div style=margin-left:16px><p>Writes all pending data to the underlying stream.</p><p>Returns false if a write error occurred on the underlying stream. (The underlying stream itself is not necessarily flushed.)</p></div><hr><h3 id=CopyingOutputStreamAdaptor.Next.details><code>virtual bool CopyingOutputStreamAdaptor::Next(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void ** data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int * size)</code></h3><div style=margin-left:16px><p>Obtains a buffer into which data can be written.</p><p>Any data written into this buffer will eventually (maybe instantly, maybe later on) be written to the output.</p><p>Preconditions:</p><ul><li>"size" and "data" are not NULL.</li></ul><p>Postconditions:</p><ul><li>If the returned value is false, an error occurred. All errors are permanent.</li><li>Otherwise, "size" points to the actual number of bytes in the buffer and "data" points to the buffer.</li><li>Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed.</li><li>Any data which the caller stores in this buffer will eventually be written to the output (unless <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingOutputStreamAdaptor.BackUp>BackUp()</a> is called).</li><li>It is legal for the returned buffer to have zero size, as long as repeatedly calling <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingOutputStreamAdaptor.Next>Next()</a> eventually yields a buffer with non-zero size.</li></ul></div><hr><h3 id=CopyingOutputStreamAdaptor.BackUp.details><code>virtual void CopyingOutputStreamAdaptor::BackUp(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style=margin-left:16px><p>Backs up a number of bytes, so that the end of the last buffer returned by <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingOutputStreamAdaptor.Next>Next()</a> is not actually written.</p><p>This is needed when you finish writing all the data you want to write, but the last buffer was bigger than you needed. You don't want to write a bunch of garbage after the end of your data, so you use <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingOutputStreamAdaptor.BackUp>BackUp()</a> to back up.</p><p>Preconditions:</p><ul><li>The last method called must have been <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingOutputStreamAdaptor.Next>Next()</a>.</li><li>count must be less than or equal to the size of the last buffer returned by <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingOutputStreamAdaptor.Next>Next()</a>.</li><li>The caller must not have written anything to the last "count" bytes of that buffer.</li></ul><p>Postconditions:</p><ul><li>The last "count" bytes of the last buffer returned by <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingOutputStreamAdaptor.Next>Next()</a> will be ignored.</li></ul></div><hr><h3 id=CopyingOutputStreamAdaptor.WriteAliasedRaw.details><code>virtual bool CopyingOutputStreamAdaptor::WriteAliasedRaw(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const void * data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size)</code></h3><div style=margin-left:16px><p>Write a given chunk of data to the output.</p><p>Some output streams may implement this in a way that avoids copying. Check AllowsAliasing() before calling <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingOutputStreamAdaptor.WriteAliasedRaw>WriteAliasedRaw()</a>. It will GOOGLE_CHECK fail if <a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingOutputStreamAdaptor.WriteAliasedRaw>WriteAliasedRaw()</a> is called on a stream that does not allow aliasing.</p><p>NOTE: It is caller's responsibility to ensure that the chunk of memory remains live until all of the data has been consumed from the stream.</p></div><h2 id=LimitingInputStream>class LimitingInputStream: public <a href=google.protobuf.io.zero_copy_stream#ZeroCopyInputStream>ZeroCopyInputStream</a></h2><p><code>#include &lt;<a href=#>google/protobuf/io/zero_copy_stream_impl_lite.h</a>><br>namespace <a href=#google.protobuf.io>google::protobuf::io</a></code></p><p>A <a href=google.protobuf.io.zero_copy_stream#ZeroCopyInputStream>ZeroCopyInputStream</a> which wraps some other stream and limits it to a particular byte count.</p><table><tr><th colspan=2><h3 style=margin-top:4px>Members</h3></th></tr><tr><td style=border-right-width:0;text-align:right><code></code></td><td style=border-left-width:0 id=LimitingInputStream.LimitingInputStream><div style=padding-left:16px;text-indent:-16px><code><b>LimitingInputStream</b>(<a href=google.protobuf.io.zero_copy_stream#ZeroCopyInputStream>ZeroCopyInputStream</a> * input, int64 limit)</code></div></td></tr><tr><td style=border-right-width:0;text-align:right><code></code></td><td style=border-left-width:0 id=LimitingInputStream.~LimitingInputStream><div style=padding-left:16px;text-indent:-16px><code><b>~LimitingInputStream</b>()</code></div></td></tr><tr><th colspan=2><h3 style=margin-top:4px;margin-bottom:4px>implements <a href=google.protobuf.io.zero_copy_stream#ZeroCopyInputStream>ZeroCopyInputStream</a></h3><div style=font-style:italic;font-weight:400></div></th></tr><tr><td style=border-right-width:0;text-align:right><code>virtual bool</code></td><td style=border-left-width:0 id=LimitingInputStream.Next><div style=padding-left:16px;text-indent:-16px><code><b>Next</b>(const void ** data, int * size)</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Obtains a chunk of data from the stream. <a href=#LimitingInputStream.Next.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual void</code></td><td style=border-left-width:0 id=LimitingInputStream.BackUp><div style=padding-left:16px;text-indent:-16px><code><b>BackUp</b>(int count)</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Backs up a number of bytes, so that the next call to <a href=google.protobuf.io.zero_copy_stream_impl_lite#LimitingInputStream.Next>Next()</a> returns data again that was already returned by the last call to <a href=google.protobuf.io.zero_copy_stream_impl_lite#LimitingInputStream.Next>Next()</a>. <a href=#LimitingInputStream.BackUp.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual bool</code></td><td style=border-left-width:0 id=LimitingInputStream.Skip><div style=padding-left:16px;text-indent:-16px><code><b>Skip</b>(int count)</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Skips a number of bytes. <a href=#LimitingInputStream.Skip.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual int64_t</code></td><td style=border-left-width:0 id=LimitingInputStream.ByteCount><div style=padding-left:16px;text-indent:-16px><code><b>ByteCount</b>() const</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Returns the total number of bytes read since this object was created.</div></td></tr></table><hr><h3 id=LimitingInputStream.Next.details><code>virtual bool LimitingInputStream::Next(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const void ** data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int * size)</code></h3><div style=margin-left:16px><p>Obtains a chunk of data from the stream.</p><p>Preconditions:</p><ul><li>"size" and "data" are not NULL.</li></ul><p>Postconditions:</p><ul><li>If the returned value is false, there is no more data to return or an error occurred. All errors are permanent.</li><li>Otherwise, "size" points to the actual number of bytes read and "data" points to a pointer to a buffer containing these bytes.</li><li>Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed.</li><li>It is legal for the returned buffer to have zero size, as long as repeatedly calling <a href=google.protobuf.io.zero_copy_stream_impl_lite#LimitingInputStream.Next>Next()</a> eventually yields a buffer with non-zero size.</li></ul></div><hr><h3 id=LimitingInputStream.BackUp.details><code>virtual void LimitingInputStream::BackUp(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style=margin-left:16px><p>Backs up a number of bytes, so that the next call to <a href=google.protobuf.io.zero_copy_stream_impl_lite#LimitingInputStream.Next>Next()</a> returns data again that was already returned by the last call to <a href=google.protobuf.io.zero_copy_stream_impl_lite#LimitingInputStream.Next>Next()</a>.</p><p>This is useful when writing procedures that are only supposed to read up to a certain point in the input, then return. If <a href=google.protobuf.io.zero_copy_stream_impl_lite#LimitingInputStream.Next>Next()</a> returns a buffer that goes beyond what you wanted to read, you can use <a href=google.protobuf.io.zero_copy_stream_impl_lite#LimitingInputStream.BackUp>BackUp()</a> to return to the point where you intended to finish.</p><p>Preconditions:</p><ul><li>The last method called must have been <a href=google.protobuf.io.zero_copy_stream_impl_lite#LimitingInputStream.Next>Next()</a>.</li><li>count must be less than or equal to the size of the last buffer returned by <a href=google.protobuf.io.zero_copy_stream_impl_lite#LimitingInputStream.Next>Next()</a>.</li></ul><p>Postconditions:</p><ul><li>The last "count" bytes of the last buffer returned by <a href=google.protobuf.io.zero_copy_stream_impl_lite#LimitingInputStream.Next>Next()</a> will be pushed back into the stream. Subsequent calls to <a href=google.protobuf.io.zero_copy_stream_impl_lite#LimitingInputStream.Next>Next()</a> will return the same data again before producing new data.</li></ul></div><hr><h3 id=LimitingInputStream.Skip.details><code>virtual bool LimitingInputStream::Skip(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count)</code></h3><div style=margin-left:16px><p>Skips a number of bytes.</p><p>Returns false if the end of the stream is reached or some input error occurred. In the end-of-stream case, the stream is advanced to the end of the stream (so <a href=google.protobuf.io.zero_copy_stream_impl_lite#LimitingInputStream.ByteCount>ByteCount()</a> will return the total size of the stream).</p></div></body></html></main><footer class="bg-dark py-5 row d-print-none"><div class="container-fluid mx-sm-5"><div class=row><div class="col-6 col-sm-4 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank rel=noopener href=https://stackoverflow.com/questions/tagged/protocol-buffers aria-label="Stack Overflow"><i class="fab fa-stack-overflow"></i></a></li></ul><script type=text/javascript id=cookiebanner src=https://cdn.jsdelivr.net/gh/dobarkod/cookie-banner@1.2.2/dist/cookiebanner.min.js data-height=40px data-message="Protobuf.dev uses cookies from Google to deliver and enhance the quality of its services and to analyze traffic." data-bg=#fff data-fg=#000 data-position=bottom data-padding=16px data-close-text="OK, got it" data-font-size=18px data-moreinfo=https://policies.google.com/technologies/cookies></script></div><div class="col-6 col-sm-4 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank rel=noopener href=https://github.com/protocolbuffers/protobuf aria-label=GitHub><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Developer mailing list" aria-label="Developer mailing list"><a class=text-white target=_blank rel=noopener href=https://groups.google.com/g/protobuf aria-label="Developer mailing list"><i class="fa fa-envelope"></i></a></li></ul><script type=text/javascript id=cookiebanner src=https://cdn.jsdelivr.net/gh/dobarkod/cookie-banner@1.2.2/dist/cookiebanner.min.js data-height=40px data-message="Protobuf.dev uses cookies from Google to deliver and enhance the quality of its services and to analyze traffic." data-bg=#fff data-fg=#000 data-position=bottom data-padding=16px data-close-text="OK, got it" data-font-size=18px data-moreinfo=https://policies.google.com/technologies/cookies></script></div><div class="col-12 col-sm-4 text-center py-2 order-sm-2"><small class=text-white>&copy; 2022 Google LLC All Rights Reserved</small>
<small class=ml-1><a href=https://policies.google.com/privacy target=_blank rel=noopener>Privacy Policy</a></small>
<span class=text-white>Hosted by GitHub Pages.</span> <a href=https://docs.github.com/en/site-policy/privacy-policies/github-privacy-statement target=_blank>GitHub Privacy Statement</a></div></div></div></footer></div><script src=/js/main.min.48a7d138dd257f31c8ab8ac8a2922a6911189eae9f353439163ad3316421ea99.js integrity="sha256-SKfRON0lfzHIq4rIopIqaREYnq6fNTQ5FjrTMWQh6pk=" crossorigin=anonymous></script>
<script src=/js/tabpane-persist.js></script></body></html>